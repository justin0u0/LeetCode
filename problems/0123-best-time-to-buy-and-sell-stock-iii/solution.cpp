/**
 * Author: justin0u0<mail@justin0u0.com>
 * Problem: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/
 * Runtime: 128ms
 * Description:
 *  dp0/dp(i,0): for prices[0:i], max profit with exactly 1 buy
 *    => dp0 = prices[i] - min{prices[j]} for all 0 < j < i
 *    => maintain `minPrice` for min{prices[j]}
 *    => dp0 = max(dp0, prices[i] - minPrice)
 *  dp1/dp(i,1): for prices[0:i], max profit with exactly 2 buys
 *    => dp1 = prices[i] + max{dp(j,0) - prices[k]} for all 0 < j < k < i
 *    => observe that everytime i increase by 1, we got a new prices[k] (let says, k' equals to i),
 *        and it generates some {dp(j,0) - prices[k']},
 *        for all {dp(j,0) - prices[k']} generated by this prices[k'],
 *        max{dp(j,0) - prices[k']} = max{dp(j,0)} - prices[k'] for all 0 < j < (k' = i)
 *        and it is obvious that max{dp(j,0)}=dp0
 *    => maintain `bestDp0` for max{dp(j,0) - prices[k]}
 *    => dp1 = max(dp1, bestDp0)
 */

class Solution {
public:
  int maxProfit(vector<int>& prices) {
    int dp0 = 0, dp1 = 0;
    int minPrice = prices[0];
    int bestDp0 = -1e9;
    for (int& price : prices) {
      dp0 = max(dp0, price - minPrice);
      dp1 = max(dp1, price + bestDp0);
      bestDp0 = max(bestDp0, dp0 - price);
      minPrice = min(minPrice, price);
    }
    return max(dp0, dp1);
  }
};

