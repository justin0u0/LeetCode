/**
 * Author: justin0u0<mail@justin0u0.com>
 * Problem: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/
 * Runtime: 0ms
 * Description: Optimize space to O(1)
 *  dp(i): for profits[0:i], max profit with a sell at day i
 *    => dp(i)=prices[i]+max{dp(j)-prices[k]}, for all 0 < j < k-1 < k < i
 *    => observe that everytime i increase by 1,
 *        we got a new prices[k] (let says, k' equals to i-1),
 *        and it generates some {dp(j) - prices[k']},
 *        for all {dp(j)-prices[k']} generated by this prices[k'],
 *        max{dp(j)-prices[k']}=max{dp(j)}-prices[k'].
 *    => observe that everytime i increase by 1,
 *        we get a new dp(j) (let says, j' equals to i-3),
 *    => from above 2 observes, maintain `maxDp` for max{dp(j)}, so maxDp=max(maxDp, dp[i-3]);
 *        also, maintain `best` for max{dp(j)}-prices[k'], so best=max(best, maxDp - prices[i-1])
 *    => so, dp(i)=prices[i]+best
 * Time Complexity: O(N)
 * Space Complexity: O(1)
 */

class Solution {
public:
  int maxProfit(vector<int>& prices) {
    // dp0 = dp(i), dp1 = dp(i - 1), dp2 = dp(i - 2)
    int dp0, dp1 = 0, dp2 = 0;
    int maxDp = 0, best = -0x3f3f3f3f;
    for (int& price : prices) {
      dp0 = price + best;
      maxDp = max(maxDp, dp2);
      best = max(best, maxDp - price);
      dp2 = dp1;
      dp1 = dp0;
    }
    return max(max(maxDp, dp2), max(dp1, dp0));
  }
};

